package util;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.List;

import com.acmemail.judah.cartesian_plane.LineGenerator;

/**
 * This is an auxiliary test class
 * for validating the lines generated
 * by a LineGenerator instance against
 * the expected values
 * as determined by the algorithm
 * described by that class.
 * See <em>Line Generation Algorithm</em>"
 * in the LineGenerator class description.
 * 
 * @author Jack Straub
 * 
 * @see LineGenerator
 *
 */
public class LineMetrics
{
    /**  List of horizontal lines generated by the LineGenerator algorithm. */
    private final List<Line2D>  hLines      = new ArrayList<>();
    /** List of Vertical lines generated by the LineGenerator algorithm. */
    private final List<Line2D>  vLines      = new ArrayList<>();
    /** 
     * Rectangle bounding the grid; 
     * see LineGenerator <b>[rule: boundingRect</b>]. 
     */
    private final Rectangle2D   boundingRect;
    /**
     * Pixels allocated per unit; 
     * see LineGenerator <b>[rule: gridUnit]</b>.
     */
    private final float         gridUnit;
    /** 
     * Grid lines per unit; 
     * see LineGenerator <b>[rule: lpu]</b>.
     */
    private final float         lpu;
    /** 
     * Spacing between lines; 
     * see LineGenerator <b>[rule: gridSpacing]</b>.
     */
    private final float         gridSpacing;
    
    /** 
     * X-coordinate of the y-axis; 
     * see LineGenerator <b>[rule: yAxis]</b>.
     */
    private final float         yAxisXco;
    /** 
     * Y-coordinate of the x-axis; 
     * see LineGenerator <b>[rule: xAxis]</b>.
     */
    private final float         xAxisYco;
    
//    private final float         floorMinXco;
//    private final float         floorMinYco;
//    private final float         maxXco;
//    private final float         maxYco;
//    private final float         ceilMaxXco;
//    private final float         ceilMaxYco;
    
    public LineMetrics(
        Rectangle2D rect,
        float       pixelsPerUnit, 
        float       linesPerUnit
    )
    {
        this.boundingRect = rect;
        this.gridUnit = pixelsPerUnit;
        this.lpu = linesPerUnit;
        
        // see LineGenerator rule: gridSpacing
        // pixels between lines
        this.gridSpacing = pixelsPerUnit / linesPerUnit;
        
        float   minXco = (float)rect.getX();
        float   maxXco = (float)rect.getWidth() + minXco;
        float   minYco = (float)rect.getY();
        float   maxYco = (float)rect.getHeight() + minYco;
        
        // see LineGenerator rule: yAxis
        // determines location of y-axis
        yAxisXco = minXco +((float)rect.getWidth() - 1) / 2;
        // determines location of x-axis
        xAxisYco = minYco + ((float)rect.getHeight() - 1) / 2;
        
//        floorMinXco = floor( minXco );
//        floorMinYco = floor( minYco );
//        ceilMaxXco = ceil( maxXco );
//        ceilMaxYco = ceil( maxYco );

        // see LineGenerator rule: numHLinesAbove
        // horizontal lines above or below x-axis
        float   halfHoriz   = 
            (float)Math.floor( rect.getHeight() / 2 / gridSpacing);
        // see LineGenerator rule: numVLinesLeft
        float   halfVert    = 
            (float)Math.floor( rect.getWidth() / 2 / gridSpacing);

        // see LineGenerator rule: nthVLineLeft
        // see LineGenerator rule: nthVLineRight
        // generate vertical lines 
        for ( float nextVert = -halfVert ; nextVert <= halfVert ; ++nextVert )
        {
            float   xco         = yAxisXco + nextVert * gridSpacing;
            Line2D  line        = 
                new Line2D.Float( xco, minYco, xco, maxYco );
            vLines.add( line );
        }
        
        // see LineGenerator rule: nthHLineAbove
        // see LineGenerator rule: nthHLineBelow
        // generate horizontal lines 
        for ( float nextHoriz = -halfHoriz ; nextHoriz <= halfHoriz ; ++nextHoriz )
        {
            float   yco = xAxisYco + nextHoriz * gridSpacing;
            Line2D  line    = 
                new Line2D.Float( minXco, yco, maxXco, yco );
            hLines.add( line );
        }
    }
    
    /**
     * Get the line segment associated 
     * with a given vertical or horizontal line
     * of a given length.
     * 
     * @param lineIn    the given horizontal or vertical line
     * @param len       the given length
     * 
     * @return the line segment with the given length
     */
    public Line2D getLineSegment( Line2D lineIn, float len )
    {
        Line2D  lineOut;
        
        float   lineInXco1  = (float)lineIn.getX1();
        if ( doubleEquals( lineInXco1, lineIn.getX2() ) )
        {
            // if x1 == x2 this is a vertical line
            float   xco     = lineInXco1;
            float   yco1    = xAxisYco - len / 2;
            float   yco2    = yco1 + len;
            lineOut = new Line2D.Float( xco, yco1, xco, yco2 );
        }
        else
        {
            // x1 != x2 this is not a vertical line,
            // it must be a horizontal line
            float   yco     = (float)lineIn.getY1();
            float   xco1    = yAxisXco - len / 2;
            float   xco2    = xco1 + len;
            lineOut = new Line2D.Float( xco1, yco, xco2, yco );
        }
        return lineOut;
    }
    
    /**
     * Gets the expected list of horizontal lines.
     * 
     * @return the expected list of horizontal lines.
     */
    public List<Line2D> getHorizLines()
    {
        return hLines;
    }
    
    /**
     * Gets the expected number of horizontal lines.
     * 
     * @return the expected number of horizontal lines.
     */
    public int getNumHorizLines()
    {
        return hLines.size();
    }

    /**
     * Gets the expected list of vertical lines.
     * 
     * @return the expected list of vertical lines.
     */
    public List<Line2D> getVertLines()
    {
        return vLines;
    }
    
    /**
     * Gets the expected number of vertical lines.
     * 
     * @return the expected number of vertical lines.
     */
    public int getNumVertLines()
    {
        return vLines.size();
    }

    /**
     * Gets the rectangle used to create this object.
     * 
     * @return the rectangle used to create this object
     */
    public Rectangle2D getRect()
    {
        return boundingRect;
    }

    /**
     * Gets the pixels-per-unit value used to create this object.
     * 
     * @return the pixels-per-unit value used to create this object
     */
    public float getGridSpacing()
    {
        return gridUnit;
    }

    /**
     * Gets the lines-per-unit value used to create this object.
     * 
     * @return the lines-per-unit value used to create this object
     */
    public float getLPU()
    {
        return lpu;
    }
    
    /**
     * Verify that two lines have the same end points,
     * within a given tolerance.
     * 
     * @param expLine     the expected line
     * @param actLine     the actual line
     * @param epsilon     the given tolerance
     */
    public static void assertLineEquals( Line2D expLine, Line2D actLine, float epsilon )
    {
        float   expLineXco1 = (float)expLine.getX1();
        float   expLineYco1 = (float)expLine.getY1();
        float   expLineXco2 = (float)expLine.getX2();
        float   expLineYco2 = (float)expLine.getY2();
        
        float   actLineXco1 = (float)actLine.getX1();
        float   actLineYco1 = (float)actLine.getY1();
        float   actLineXco2 = (float)actLine.getX2();
        float   actLineYco2 = (float)actLine.getY2();
        
        String  fmt         =
            "Expected: Line2D(%.1f,%.1f,%.1f,%.1f) "
            + "Actual: Line2D(%.1f,%.1f,%.1f,%.1f)";
        String  msg         =
            String.format(
                fmt,
                expLineXco1,
                expLineYco1,
                expLineXco2,
                expLineYco2,
                actLineXco1,
                actLineYco1,
                actLineXco2,
                actLineYco2
            );
        assertEquals( expLineXco1, actLineXco1, epsilon, msg );
        assertEquals( expLineYco1, actLineYco1, epsilon, msg );
        assertEquals( expLineXco2, actLineXco2, epsilon, msg );
        assertEquals( expLineYco2, actLineYco2, epsilon, msg );
    }

//    private void validateEndpoints( Line2D line )
//    {
//        assertGE( ceil( line.getX1() ), floorMinXco );
//        assertGE( ceil( line.getY1() ), floorMinYco );
//        assertLT( floor( line.getX2() ), ceilMaxXco );
//        assertLT( floor( line.getY2() ), ceilMaxYco );
//    }
//    
//    private static float floor( double valIn )
//    {
//        float   valOut  = (float)Math.floor( valIn );
//        return valOut;
//    }
//    
//    private static float ceil( double valIn )
//    {
//        float   valOut  = (float)Math.ceil( valIn );
//        return valOut;
//    }
//    
    private static boolean doubleEquals( double fVal1, double fVal2 )
    {
        final double    epsilon = .001f;
        double          diff    = Math.abs( fVal1 - fVal2 );
        boolean         result  = diff < epsilon;
        return result;
    }
//    
//    private static void assertGE( float leftVal, float rightVal )
//    {
//        String  msg     = "Testing " + leftVal + " >= " + rightVal;
//        assertTrue( leftVal >= rightVal, msg );
//    }
//    
//    private static void assertLT( float leftVal, float rightVal )
//    {
//        String  msg     = "Testing " + leftVal + " >= " + rightVal;
//        assertTrue( leftVal < rightVal, msg );
//    }
}
